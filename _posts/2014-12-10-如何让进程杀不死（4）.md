
---
layout: post
title:  " 如何让进程杀不死（4）"
date:   2014-12-10 16:14:09 +0800
categories: Android
---



是时候展示真正的技术了！！！！！
我要用JNI 、NDK；
 
 正常来说使用native保活实现方案也是大多数公司采用的方案，
	技术关键点：开启native子进程，定时发intent
	结论：单杀可以杀死，force close 5.0以上无效，5.0以下部分手机无效，第三方软件下无效，且无法保证实时常驻
 但是如果只是一个C进程去轮询的话，还是很容易就会被各大清理软件清理掉。那么我们怎么样可以使我们的进程更加顽固？？
 我心有一计！！
双向的守护进程：
那么怎么样才能实现双向守护呢？首先我们想到的是fork这个函数，他会创建一个子进程，然后在父进程中调用waitpid()这个函数，这是一个阻塞函数，他会一直wait到子进程挂掉，才会继续向下执行，利用这个机制，我们可以在主进程的c层fork一个子进程，然后父进程就可以监听到子进程的死亡，死亡的时候再重启子进程。
似乎可以用这个机制改进刚刚上面分析的那个工程，因为这样的话：1，无法直接杀掉子进程。2、子进程不死，他就会按时发intent给父进程。
这样做，普通杀是没有问题。但是force close不会按照你的要求先杀孩子，等你把孩子启动起来，再杀父亲，然后坐视子进程在那不管，三方软件自不必说。那么先杀父进程的话，子进程就没办法监听到父进程的死亡吗？
有朋友要说可以利用Linux的进程领养机制，如果父进程挂掉，那么子进程就会被linux的init进程领养，进程所对应的父进程id也会变成1。这的确是一个很好的标示，但是要怎样监听这个状态的变化呢？轮询获取父进程id，然后判断是否等于1？那么轮询的间隔为多少合适？1秒间隔算短算长？设为1秒的话force close掉你的时候，根本不会等到你那每秒正时正点的轮询点上，会被forceclose直接干掉，我试过更短的时间，基本要小到小于10毫秒的时间间隔，才有可能再force close的时候检测到，并成功拉起父进程。注意我的关键词，小于10毫秒！才可能！对，一秒100次的检查，才有可能，只是可能！手机待机十分钟就已经可以开始烫手，三个小时电池发出了低电量警告。代码：![这里写图片描述](http://img.blog.csdn.net/20170217102720638?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQva3N3czAzMjA0MDM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

技术关键点：fork子进程 ,waitpid监听子进程 ,通过linux进程领养机制监听父进程
结论：保证单杀存活，保活效果与耗电成正比，得不偿失（5.0以上无效）
好，我们继续。
waitpid是阻塞函数，所以他一定是没有耗电问题的，即时性也没有问题。那么问题就集中在了子进程如何监听到父进程的死亡上面，把那个轮询替掉。
然后，我想到的是管道，linux中有多种ipc通信机制，管道是最基本的一种通信方式，且这种管道只能在父子进程间建立，于是我想是否能利用这个机制呢？在父子进程间建立管道，但是并不写入数据，只是使用阻塞方法在另一端去读取管道，这样如果对方进程挂掉，管道会被破坏，那么另一端的读取方法就会执行返回，由此确定对方挂掉然后重启对方。 
详情http://blog.csdn.net/marswin89/article/details/50899838
 

 
 
 
 
